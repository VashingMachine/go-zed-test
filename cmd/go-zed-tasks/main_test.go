package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var configEnvKeys = []string{
	"ZED_GO_TASKS_TASKS_PATH",
	"ZED_GO_TASKS_DEBUG_PATH",
	"ZED_GO_TASKS_LABEL_PREFIX",
	"ZED_GO_TASKS_DEBUG_LABEL_PREFIX",
	"ZED_GO_TASKS_GO_BINARY",
	"ZED_GO_TASKS_TEST_NAME_REGEX",
	"ZED_GO_TASKS_GO_LIST_REGEX",
	"ZED_GO_TASKS_ADDITIONAL_GO_TEST_ARGS",
	"ZED_GO_TASKS_USE_NEW_TERMINAL",
	"ZED_GO_TASKS_ALLOW_CONCURRENT_RUNS",
	"ZED_GO_TASKS_REVEAL",
	"ZED_GO_TASKS_HIDE",
	"ZED_GO_TASKS_PRUNE_GENERATED",
	"ZED_GO_TASKS_GENERATED_ENV_KEY",
	"ZED_GO_TASKS_GENERATED_ENV_VALUE",
	"ZED_GO_TASKS_SUBTEST_DISCOVERY_TIMEOUT",
}

func TestRun_HelpAndUnknownCommand(t *testing.T) {
	err := run([]string{"help"})
	require.NoError(t, err)

	err = run([]string{"unknown"})
	require.Error(t, err)
	assert.Contains(t, err.Error(), "missing required flag: -file")
}

func TestFindTestsInFile_IgnoresMethodsAndNonMatchingNames(t *testing.T) {
	root := t.TempDir()
	filePath := filepath.Join(root, "sample_test.go")

	writeFile(t, filePath, `package sample
import "testing"

type svc struct{}
func (s svc) TestMethod(t *testing.T) {}

func helper() {}
func BenchmarkOne(b *testing.B) {}
func TestAlpha(t *testing.T) {}
func TestBeta(t *testing.T) {}
`)

	pattern := regexp.MustCompile(`^Test`)
	tests, err := findTestsInFile(filePath, pattern)
	require.NoError(t, err)

	sort.Strings(tests)
	assert.Equal(t, []string{"TestAlpha", "TestBeta"}, tests)
}

func TestReadTasks_SupportsCommentsAndTrailingCommas(t *testing.T) {
	root := t.TempDir()
	tasksPath := filepath.Join(root, "tasks.json")

	writeFile(t, tasksPath, `[
  // A manual task
  {
    "label": "manual",
    "command": "echo",
    "args": ["ok",],
  },
  /* Generated by tool */
  {
    "label": "go:TestOne",
    "command": "go",
    "env": {
      "ZED_GO_TEST_TASK_GENERATED": "1",
    },
  },
]`)

	tasks, err := readTasks(tasksPath)
	require.NoError(t, err)
	require.Len(t, tasks, 2)

	manual := taskByLabel(t, tasks, "manual")
	assert.Equal(t, "echo", manual["command"])

	generated := taskByLabel(t, tasks, "go:TestOne")
	assert.Equal(t, "go", generated["command"])
}

func TestMergeTasks_PrunesGeneratedAndUpsertsByLabel(t *testing.T) {
	root := t.TempDir()
	tasksPath := filepath.Join(root, "tasks.json")
	cfg := Config{
		GeneratedEnvKey:   "ZED_GO_TEST_TASK_GENERATED",
		GeneratedEnvValue: "1",
		PruneGenerated:    true,
	}

	writeFile(t, tasksPath, `[
  {
    "label": "manual",
    "command": "echo"
  },
  {
    "label": "go:TestOld",
    "command": "go",
    "env": {
      "ZED_GO_TEST_TASK_GENERATED": "1"
    }
  },
  {
    "label": "go:TestNew",
    "command": "old-command"
  }
]`)

	generated := []map[string]any{
		{
			"label":   "go:TestNew",
			"command": "go",
			"env": map[string]any{
				cfg.GeneratedEnvKey: cfg.GeneratedEnvValue,
			},
		},
		{
			"label":   "go:TestAdded",
			"command": "go",
			"env": map[string]any{
				cfg.GeneratedEnvKey: cfg.GeneratedEnvValue,
			},
		},
	}

	merged, stats, err := mergeTasks(tasksPath, generated, cfg)
	require.NoError(t, err)

	assert.Equal(t, 1, stats.Removed)
	assert.Equal(t, 1, stats.Updated)
	assert.Equal(t, 1, stats.Added)

	assert.NotNil(t, taskByLabel(t, merged, "manual"))
	assert.NotNil(t, taskByLabel(t, merged, "go:TestNew"))
	assert.NotNil(t, taskByLabel(t, merged, "go:TestAdded"))
	assert.Nil(t, findTaskByLabel(merged, "go:TestOld"))
}

func TestRunGenerate_CreatesTasksForCurrentFileAndPreservesManual(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	moduleDir := filepath.Join(root, "pkg")
	targetFile := filepath.Join(moduleDir, "target_test.go")
	tasksPath := filepath.Join(root, ".zed", "tasks.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestAlpha(t *testing.T) {}
func TestBeta(t *testing.T) {}
`)
	writeFile(t, filepath.Join(moduleDir, "other_test.go"), `package sample
import "testing"

func TestFromOtherFile(t *testing.T) {}
`)

	// Existing tasks include one manual task and one old generated task.
	writeFile(t, tasksPath, `[
  {
    "label": "manual",
    "command": "echo"
  },
  {
    "label": "go:Old",
    "command": "go",
    "env": {
      "ZED_GO_TEST_TASK_GENERATED": "1"
    }
  }
]`)

	err := runGenerate([]string{
		"-file", targetFile,
		"-root", root,
		"-tasks", tasksPath,
	}, generateTargetTasks)
	require.NoError(t, err)

	tasks := readTasksForTest(t, tasksPath)
	labels := labelsFromTasks(tasks)
	sort.Strings(labels)

	assert.Equal(t, []string{"go:TestAlpha", "go:TestBeta", "manual"}, labels)

	alphaTask := taskByLabel(t, tasks, "go:TestAlpha")
	assert.Equal(t, "go", alphaTask["command"])
	assert.Equal(t, "always", alphaTask["reveal"])
	assert.Equal(t, "never", alphaTask["hide"])

	args := toStringSlice(t, alphaTask["args"])
	assert.Equal(t, []string{"test", "./pkg", "-run", "^TestAlpha$"}, args)

	env := toStringMap(t, alphaTask["env"])
	assert.Equal(t, "1", env["ZED_GO_TEST_TASK_GENERATED"])
	assert.Equal(t, "TestAlpha", env["ZED_GO_TEST_NAME"])
	assert.Equal(t, "pkg/target_test.go", env["ZED_GO_TEST_FILE"])
}

func TestRunGenerate_UsesEnvValues(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	targetFile := filepath.Join(root, "target_test.go")
	customTasksPath := filepath.Join(root, ".zed", "custom_tasks.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestOne(t *testing.T) {}
`)

	setEnv(t, "ZED_GO_TASKS_TASKS_PATH", ".zed/custom_tasks.json")
	setEnv(t, "ZED_GO_TASKS_LABEL_PREFIX", "unit:")
	setEnv(t, "ZED_GO_TASKS_ADDITIONAL_GO_TEST_ARGS", "-count=1")
	setEnv(t, "ZED_GO_TASKS_GENERATED_ENV_KEY", "AUTO_TASK")
	setEnv(t, "ZED_GO_TASKS_GENERATED_ENV_VALUE", "yes")

	err := runGenerate([]string{
		"-file", targetFile,
		"-root", root,
	}, generateTargetTasks)
	require.NoError(t, err)

	tasks := readTasksForTest(t, customTasksPath)
	require.Len(t, tasks, 1)

	task := taskByLabel(t, tasks, "unit:TestOne")
	args := toStringSlice(t, task["args"])
	assert.Equal(t, []string{"test", "-count=1", ".", "-run", "^TestOne$"}, args)

	env := toStringMap(t, task["env"])
	assert.Equal(t, "yes", env["AUTO_TASK"])
}

func TestRunGenerate_UsesCommandLineGoTestArgs(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	targetFile := filepath.Join(root, "target_test.go")
	tasksPath := filepath.Join(root, ".zed", "tasks.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestOne(t *testing.T) {}
`)

	err := runGenerate([]string{
		"-file", targetFile,
		"-root", root,
		"-tasks", tasksPath,
		"-go-test-arg=-v",
		"-go-test-arg=-count=1",
		"--",
		"-timeout=30s",
	}, generateTargetTasks)
	require.NoError(t, err)

	tasks := readTasksForTest(t, tasksPath)
	require.Len(t, tasks, 1)
	task := taskByLabel(t, tasks, "go:TestOne")

	args := toStringSlice(t, task["args"])
	assert.Equal(t, []string{"test", "-v", "-count=1", "-timeout=30s", ".", "-run", "^TestOne$"}, args)
}

func TestRunGenerate_PrintsEachGeneratedTask(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	targetFile := filepath.Join(root, "target_test.go")
	tasksPath := filepath.Join(root, ".zed", "tasks.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestAlpha(t *testing.T) {}
func TestBeta(t *testing.T) {}
`)

	out := captureStdout(t, func() {
		err := runGenerate([]string{
			"-file", targetFile,
			"-root", root,
			"-tasks", tasksPath,
		}, generateTargetTasks)
		require.NoError(t, err)
	})

	assert.Contains(t, out, "Generated task: go:TestAlpha")
	assert.Contains(t, out, "Generated task: go:TestBeta")
}

func TestRunGenerateDebug_WritesDebugConfigs(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	targetFile := filepath.Join(root, "target_test.go")
	debugPath := filepath.Join(root, ".zed", "debug.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestOne(t *testing.T) {}
`)

	err := runGenerate([]string{
		"-file", targetFile,
		"-root", root,
		"-debug", debugPath,
		"-go-test-arg=-v",
		"-go-test-arg=-count=1",
	}, generateTargetDebug)
	require.NoError(t, err)

	configs := readTasksForTest(t, debugPath)
	require.Len(t, configs, 1)

	config := taskByLabel(t, configs, "go:debug:TestOne")
	assert.Equal(t, "Delve", config["adapter"])
	assert.Equal(t, "launch", config["request"])
	assert.Equal(t, "test", config["mode"])
	assert.Equal(t, ".", config["program"])

	args := toStringSlice(t, config["args"])
	assert.Equal(t, []string{"-test.v", "-test.count=1", "-test.run", "^TestOne$"}, args)

	env := toStringMap(t, config["env"])
	assert.Equal(t, "1", env["ZED_GO_TEST_TASK_GENERATED"])
	assert.Equal(t, "TestOne", env["ZED_GO_TEST_NAME"])
	assert.Equal(t, "target_test.go", env["ZED_GO_TEST_FILE"])
}

func TestRunGenerate_DiscoverSubtests_GeneratesTasksForDiscoveredSubtests(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	moduleDir := filepath.Join(root, "pkg")
	targetFile := filepath.Join(moduleDir, "target_test.go")
	tasksPath := filepath.Join(root, ".zed", "tasks.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestWithSubtests(t *testing.T) {
  cases := []string{"one", "two"}
  for _, tc := range cases {
    tc := tc
    t.Run(tc, func(t *testing.T) {})
  }

  t.Run("nested", func(t *testing.T) {
    t.Run("leaf", func(t *testing.T) {})
  })
}

func TestPlain(t *testing.T) {}
`)
	writeFile(t, filepath.Join(moduleDir, "other_test.go"), `package sample
import "testing"

func TestFromOtherFile(t *testing.T) {}
`)

	out := captureStdout(t, func() {
		err := runGenerate([]string{
			"-file", targetFile,
			"-root", root,
			"-tasks", tasksPath,
			"-discover-subtests",
		}, generateTargetTasks)
		require.NoError(t, err)
	})
	assert.Contains(t, out, "Discovered by runtime execution: 6 (new: 4, timeout 30s)")

	tasks := readTasksForTest(t, tasksPath)
	labels := labelsFromTasks(tasks)
	sort.Strings(labels)
	assert.Equal(t, []string{
		"go:TestPlain",
		"go:TestWithSubtests",
		"go:TestWithSubtests/nested",
		"go:TestWithSubtests/nested/leaf",
		"go:TestWithSubtests/one",
		"go:TestWithSubtests/two",
	}, labels)

	leafTask := taskByLabel(t, tasks, "go:TestWithSubtests/nested/leaf")
	args := toStringSlice(t, leafTask["args"])
	assert.Equal(t, []string{"test", "./pkg", "-run", "^TestWithSubtests$/^nested$/^leaf$"}, args)
}

func TestRunGenerateDebug_DiscoverSubtests_GeneratesDebugConfigs(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	moduleDir := filepath.Join(root, "pkg")
	targetFile := filepath.Join(moduleDir, "target_test.go")
	debugPath := filepath.Join(root, ".zed", "debug.json")

	writeFile(t, filepath.Join(root, "go.mod"), "module example.com/sample\n\ngo 1.22\n")
	writeFile(t, targetFile, `package sample
import "testing"

func TestWithSubtests(t *testing.T) {
  t.Run("one", func(t *testing.T) {})
}
`)

	out := captureStdout(t, func() {
		err := runGenerate([]string{
			"-file", targetFile,
			"-root", root,
			"-debug", debugPath,
			"-discover-subtests",
		}, generateTargetDebug)
		require.NoError(t, err)
	})
	assert.Contains(t, out, "Discovered by runtime execution: 2 (new: 1, timeout 30s)")

	configs := readTasksForTest(t, debugPath)
	labels := labelsFromTasks(configs)
	sort.Strings(labels)
	assert.Equal(t, []string{
		"go:debug:TestWithSubtests",
		"go:debug:TestWithSubtests/one",
	}, labels)

	oneConfig := taskByLabel(t, configs, "go:debug:TestWithSubtests/one")
	args := toStringSlice(t, oneConfig["args"])
	assert.Equal(t, []string{"-test.run", "^TestWithSubtests$/^one$"}, args)
}

func TestRunClear_RemovesOnlyGeneratedTasks(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	tasksPath := filepath.Join(root, ".zed", "tasks.json")

	// Intentionally uses relaxed JSON syntax.
	writeFile(t, tasksPath, `[
  {
    "label": "manual",
    "command": "echo",
  },
  {
    "label": "go:Generated",
    "command": "go",
    "env": {
      "ZED_GO_TEST_TASK_GENERATED": "1",
    },
  },
  {
    "label": "go:LooksGeneratedButIsNot",
    "command": "go",
    "env": {
      "ZED_GO_TEST_TASK_GENERATED": "0",
    },
  },
]`)

	err := runClear([]string{
		"-root", root,
		"-tasks", tasksPath,
	})
	require.NoError(t, err)

	tasks := readTasksForTest(t, tasksPath)
	labels := labelsFromTasks(tasks)
	sort.Strings(labels)
	assert.Equal(t, []string{"go:LooksGeneratedButIsNot", "manual"}, labels)
}

func TestRunClear_UsesCustomGeneratedMarker(t *testing.T) {
	clearConfigEnv(t)

	root := t.TempDir()
	tasksPath := filepath.Join(root, ".zed", "tasks.json")

	setEnv(t, "ZED_GO_TASKS_GENERATED_ENV_KEY", "AUTO")
	setEnv(t, "ZED_GO_TASKS_GENERATED_ENV_VALUE", "true")
	writeFile(t, tasksPath, `[
  {
    "label": "manual",
    "command": "echo"
  },
  {
    "label": "unit:Generated",
    "command": "go",
    "env": {
      "AUTO": "true"
    }
  },
  {
    "label": "unit:Keep",
    "command": "go",
    "env": {
      "AUTO": "false"
    }
  }
]`)

	err := runClear([]string{
		"-root", root,
		"-tasks", tasksPath,
	})
	require.NoError(t, err)

	tasks := readTasksForTest(t, tasksPath)
	labels := labelsFromTasks(tasks)
	sort.Strings(labels)
	assert.Equal(t, []string{"manual", "unit:Keep"}, labels)
}

func TestStripJSONComments_UnterminatedBlockCommentReturnsError(t *testing.T) {
	_, err := stripJSONComments([]byte(`[{/* broken`))
	require.Error(t, err)
	assert.Contains(t, err.Error(), "unterminated block comment")
}

func TestRunPatternForTestName_BuildsSegmentAwarePattern(t *testing.T) {
	assert.Equal(t, "^TestTop$", runPatternForTestName("TestTop"))
	assert.Equal(t, "^TestTop$/^child$/^leaf$", runPatternForTestName("TestTop/child/leaf"))
}

func writeFile(t *testing.T, path string, content string) {
	t.Helper()
	require.NoError(t, os.MkdirAll(filepath.Dir(path), 0o755))
	require.NoError(t, os.WriteFile(path, []byte(content), 0o644))
}

func readTasksForTest(t *testing.T, path string) []map[string]any {
	t.Helper()
	tasks, err := readTasks(path)
	require.NoError(t, err)
	return tasks
}

func labelsFromTasks(tasks []map[string]any) []string {
	labels := make([]string, 0, len(tasks))
	for _, task := range tasks {
		if label, ok := task["label"].(string); ok {
			labels = append(labels, label)
		}
	}
	return labels
}

func findTaskByLabel(tasks []map[string]any, label string) map[string]any {
	for _, task := range tasks {
		if got, ok := task["label"].(string); ok && got == label {
			return task
		}
	}
	return nil
}

func taskByLabel(t *testing.T, tasks []map[string]any, label string) map[string]any {
	t.Helper()
	task := findTaskByLabel(tasks, label)
	require.NotNil(t, task, "expected task with label %q", label)
	return task
}

func toStringSlice(t *testing.T, v any) []string {
	t.Helper()

	switch typed := v.(type) {
	case []string:
		return typed
	case []any:
		out := make([]string, 0, len(typed))
		for _, item := range typed {
			str, ok := item.(string)
			require.True(t, ok, "expected string item in slice, got %T", item)
			out = append(out, str)
		}
		return out
	default:
		require.FailNowf(t, "invalid type", "expected []string or []any, got %T", v)
		return nil
	}
}

func toStringMap(t *testing.T, v any) map[string]string {
	t.Helper()

	switch typed := v.(type) {
	case map[string]string:
		return typed
	case map[string]any:
		out := make(map[string]string, len(typed))
		for k, item := range typed {
			str, ok := item.(string)
			require.True(t, ok, "expected string value for key %q, got %T", k, item)
			out[k] = str
		}
		return out
	default:
		raw, _ := json.Marshal(v)
		require.FailNowf(t, "invalid type", "expected map[string]string or map[string]any, got %T (%s)", v, string(raw))
		return nil
	}
}

func captureStdout(t *testing.T, fn func()) string {
	t.Helper()

	old := os.Stdout
	r, w, err := os.Pipe()
	require.NoError(t, err)
	os.Stdout = w
	defer func() {
		os.Stdout = old
	}()

	fn()

	require.NoError(t, w.Close())

	var buf bytes.Buffer
	_, err = io.Copy(&buf, r)
	require.NoError(t, err)
	require.NoError(t, r.Close())

	return strings.ReplaceAll(buf.String(), "\r\n", "\n")
}

func clearConfigEnv(t *testing.T) {
	t.Helper()
	for _, envKey := range configEnvKeys {
		key := envKey
		oldValue, wasSet := os.LookupEnv(key)
		require.NoError(t, os.Unsetenv(key))
		t.Cleanup(func() {
			if wasSet {
				_ = os.Setenv(key, oldValue)
				return
			}
			_ = os.Unsetenv(key)
		})
	}
}

func setEnv(t *testing.T, key, value string) {
	t.Helper()
	oldValue, wasSet := os.LookupEnv(key)
	require.NoError(t, os.Setenv(key, value))
	t.Cleanup(func() {
		if wasSet {
			_ = os.Setenv(key, oldValue)
			return
		}
		_ = os.Unsetenv(key)
	})
}

func TestSubtest(t *testing.T) {
	t.Parallel()
	for i := range 3 {
		t.Run(fmt.Sprintf("subtest-%d", i), func(t *testing.T) {
			t.Parallel()
			t.Run("subsubtest", func(t *testing.T) {
				t.Parallel()
				t.Log("subsubtest")
			})
		})
	}
	t.Run("failed", func(t *testing.T) {
		t.Parallel()
		t.Fail()
	})
}
